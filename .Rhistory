library(maids)
lmbd_grid <- fx_vars[! grepl('_', names(fx_vars))] %>% lambda_grid(lambda_range = as.vector(outer(seq(1, 10, 1), 10^(-3:-1))))
lmbd_grid
expect_is(lmbd_grid, 'tbl_df')
expect_equal(nrow(lmbd_grid), length(unique(lmbd_grid$lambda_main)))
names(fx_vars)[!grepl('_', names(fx_vars))]
sum(! grepl('_', names(fx_vars)))
expect_equal(nrow(lmbd_grid), length(unique(lmbd_grid$lambda_main)))
expect_equal(ncol(lmbd_grid), 1 + sum(! grepl('_', names(fx_vars))))
names(lmbd_grid) %in% c('lambda_main', names(fx_vars)[!grepl('_', names(fx_vars))])
expect_true(all(names(lmbd_grid) %in% c('lambda_main', names(fx_vars)[!grepl('_', names(fx_vars))])))
expect_equal(sum(is.na(lmbd_grid)), 0)
lmbd_grid <- fx_vars[grepl('_', names(fx_vars))] %>% lambda_grid(lambda_range = as.vector(outer(seq(1, 10, 1), 10^(-3:-1))))
expect_equal(ncol(lmbd_grid), 1 + sum(grepl('_', names(fx_vars))))
expect_true(all(names(lmbd_grid) %in% c('lambda_intr', names(fx_vars)[grepl('_', names(fx_vars))])))
expect_equal(sum(is.na(lmbd_grid)), 0)
lmbd_grid <- fx_vars %>% lambda_grid(lambda_range = as.vector(outer(seq(1, 10, 1), 10^(-3:-1))))
expect_is(lmbd_grid, 'tbl_df')
expect_equal(nrow(lmbd_grid), length(unique(lmbd_grid$lambda_main)) * length(unique(lmbd_grid$lambda_intr)))
expect_equal(ncol(lmbd_grid), 2 + length(names(fx_vars)))
expect_true(all(names(lmbd_grid) %in% c('lambda_main', 'lambda_intr', names(fx_vars))))
expect_equal(sum(is.na(lmbd_grid)), 0)
devtools::load_all(".")
devtools::load_all(".")
library(maids)
library(maids)
data('mtpl_be')
library(gbm)
set.seed(54321)
gbm_be <- gbm(nclaims ~ offset(log(expo)) + ageph + power + bm + agec + coverage + fuel + sex + fleet + use,
data = mtpl_be, distribution = 'poisson', shrinkage = 0.01, n.trees = 500, interaction.depth = 3)
library(magrittr)
gbm_fun <- function(object, newdata) mean(predict(object, newdata, n.trees = object$n.trees, type = 'response'))
fx_vars_be <- gbm_be %>% insights(vars = c('ageph', 'power', 'ageph_power'),
data = mtpl_be,
interactions = 'user',
pred_fun = gbm_fun)
pd <- fx_vars_be[['ageoh_power']]
lambda <- 0.0001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i))
pd
pd <- fx_vars_be[['ageph_power']]
lambda <- 0.0001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i))
loss_func <- function(pd, lambda, ngroups){
pd_grp <- pd %>% group_pd(ngroups = ngroups)
if (pd_grp %>% is.null) return(Inf)
pd_grp %>% dplyr::ungroup() %>%
dplyr::summarize(loss = (sum(w * abs(y - ygrp))/sum(w)) + (lambda * log10(length(unique(xgrp))))) %>%
dplyr::pull(loss)
}
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist
search_grid
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.01
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0005
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
pd %>% group_pd(ngroups = 15)
pd %>% group_pd(ngroups = 14)
loss_func <- function(pd, lambda, ngroups){
pd_grp <- pd %>% group_pd(ngroups = ngroups)
if (pd_grp %>% is.null) return(Inf)
pd_grp %>% dplyr::ungroup() %>%
#dplyr::summarize(loss = (sum(w * abs(y - ygrp))/sum(w)) + (lambda * log10(length(unique(xgrp))))) %>%
dplyr::summarize(loss = (mean(abs(y - ygrp))) + (lambda * log10(length(unique(xgrp))))) %>%
dplyr::pull(loss)
}
pd <- fx_vars_be[['ageph_power']]
lambda <- 0.0005
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.01
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.002
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.003
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.004
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.005
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0045
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0047
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0048
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
loss_func <- function(pd, lambda, ngroups){
pd_grp <- pd %>% group_pd(ngroups = ngroups)
if (pd_grp %>% is.null) return(Inf)
pd_grp %>% dplyr::ungroup() %>%
#dplyr::summarize(loss = (sum(w * abs(y - ygrp))/sum(w)) + (lambda * log10(length(unique(xgrp))))) %>%
dplyr::summarize(loss = (mean((y - ygrp)^2)) + (lambda * log10(length(unique(xgrp))))) %>%
dplyr::pull(loss)
}
lambda <- 0.0048
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00005
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.000001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0000001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
pd <- fx_vars_be[['ageph']]
lambda <- 0.0000001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.0005
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00005
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00002
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00003
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.00001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
lambda <- 0.000012
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
lambda <- 0.000015
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
lambda <- 0.00002
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
lambda <- 0.00001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
lambda <- 0.000009
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
lambda <- 0.000007
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
lambda <- 0.000001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
pd <- fx_vars_be[['ageph_power']]
lambda <- 0.000001
search_grid <- seq_len(min(length(unique(pd$y)), 15))
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% plot
search_grid %>% purrr::map(function(i) loss_func(pd, lambda, i)) %>% unlist %>% which.min
# Create the hexSticker for maids
hexSticker::sticker('maids.png', package = 'maids',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maids_hex.png')
# Create the hexSticker for maids
hexSticker::sticker('maids.png', package = 'maidr',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maids_hex.png')
# Create the hexSticker for maids
hexSticker::sticker('maids.png', package = 'maidrr',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maids_hex.png')
# Create the hexSticker for maids
hexSticker::sticker('maids.png', package = 'maidrrr',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maids_hex.png')
pd %>% plot_pd
ggplot(pd, aes(x1, x2)) + geom_raster(aes(fill = y))
library(ggplot2)
ggplot(pd, aes(x1, x2)) + geom_raster(aes(fill = y))
ggplot(pd, aes(x1, x2)) + geom_tile(aes(fill = y))
ggplot(pd, aes(x1, x2)) + geom_tile(aes(fill = y), interpolate = TRUE)
ggplot(pd, aes(x1, x2)) + geom_raster(aes(fill = y), interpolate = TRUE)
ggplot(pd, aes(x1, x2)) + geom_raster(aes(fill = y), interpolate = FALSE)
ggplot(pd, aes(x1, x2)) + geom_tile(aes(fill = y))
ggplot(pd, aes(x1, x2)) + geom_tile(aes(fill = y, alpha = w))
# Create the hexSticker for maids
hexSticker::sticker('maids.png', package = 'maidrr',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maids_hex.png')
# Create the hexSticker for maids
hexSticker::sticker('maids.png', package = 'maidr',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maids_hex.png')
# Create the hexSticker for maids
hexSticker::sticker('maids.png', package = 'maidrr',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maids_hex.png')
devtools::load_all(".")
library(maids)
library(maids)
# Use a gbm fit on the mtpl_be data to test the partial dependence function
if (!requireNamespace('gbm', quietly = TRUE)) {
stop('Package "gbm" needed for this function to work. Please install it.',
call. = FALSE)
}
data('mtpl_be')
features <- setdiff(names(mtpl_be),c('id', 'nclaims', 'expo'))
set.seed(12345)
gbm_fit <- gbm::gbm(as.formula(paste('nclaims ~',
paste(features, sep = ' ', collapse = ' + '))),
distribution = 'poisson',
data = mtpl_be,
n.trees = 50,
interaction.depth = 3,
shrinkage = 0.1)
gbm_fun <- function(object, newdata) mean(predict(object, newdata, n.trees = object$n.trees, type = 'response'))
ngrp <- gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.001)
ngrp
ngrp <- gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001)
ngrp
gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001, search_grid = c(1, 2.3, 5.6, 8))
expect_warning(gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001, search_grid = c(1, 2.3, 5.6, 8)),
'Non-integers are supplied in search_grid. These are converted to integers so interpret the result with care.')
expect_equal(suppressWarnings(gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001, search_grid = c(1, 2.3, 5.6, 8))), 5)
test_that('output is of the expected format', {
ngrp <- gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001)
expect_is(ngrp, 'integer')
expect_equal(ngrp, 3)
})
test_that('an error is produced when the search grid is empty', {
expect_error(gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001, search_grid = integer()),
'Search grid should contain at least one value.')
})
test_that('a warning is produced when there are non-integers present in the search grid, but still with output', {
expect_warning(gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001, search_grid = c(1, 2.3, 5.6, 8)),
'Non-integers are supplied in search_grid. These are converted to integers so interpret the result with care.')
expect_equal(suppressWarnings(gbm_fit %>% get_pd(var = 'ageph',
grid = data.frame('ageph' = 20:80),
data = mtpl_be,
subsample = 1000,
fun = gbm_fun) %>%
optimal_ngroups(lambda = 0.0001, search_grid = c(1, 2.3, 5.6, 8))), 5)
})
library(maids)
# Use a gbm fit on the mtpl_be data to test the partial dependence function
if (!requireNamespace('gbm', quietly = TRUE)) {
stop('Package "gbm" needed for this function to work. Please install it.',
call. = FALSE)
}
data('mtpl_be')
features <- setdiff(names(mtpl_be),c('id', 'nclaims', 'expo'))
set.seed(12345)
gbm_fit <- gbm::gbm(as.formula(paste('nclaims ~',
paste(features, sep = ' ', collapse = ' + '))),
distribution = 'poisson',
data = mtpl_be,
n.trees = 50,
interaction.depth = 3,
shrinkage = 0.1)
gbm_fun <- function(object, newdata) mean(predict(object, newdata, n.trees = object$n.trees, type = 'response'))
seg_dat <- gbm_fit %>% insights(vars = c('ageph', 'bm', 'coverage', 'fuel', 'bm_fuel', 'ageph_coverage'),
data = mtpl_be,
interactions = 'user',
pred_fun = gbm_fun) %>%
segmentation(data = mtpl_be,
lambda = 0.0001)
str(seg_dat)
test_that('surrogate is fit properly when data is piped in', {
sur_glm <- seg_dat %>% surrogate(par_list = alist(formula = nclaims ~ ageph_ + bm_ + fuel_,
family =  poisson(link = 'log'),
offset = log(expo)))
expect_is(sur_glm, 'glm')
expect_match(sur_glm$family$family, 'poisson')
expect_match(sur_glm$family$link, 'log')
expect_true(all(sur_glm$offset == log(mtpl_be$expo)))
expect_true(all(sur_glm$data == seg_dat))
})
test_that('surrogate is fit properly when data is inserted at a random location in the function call', {
sur_glm <- surrogate(par_list = alist(formula = nclaims ~ ageph_ + bm_ + fuel_,
family =  poisson(link = 'log'),
offset = log(expo)),
data = seg_dat)
expect_is(sur_glm, 'glm')
expect_match(sur_glm$family$family, 'poisson')
expect_match(sur_glm$family$link, 'log')
expect_true(all(sur_glm$offset == log(mtpl_be$expo)))
expect_true(all(sur_glm$data == seg_dat))
})
library(maids)
# Use a gbm fit on the mtpl_be data to test the partial dependence function
if (!requireNamespace('gbm', quietly = TRUE)) {
stop('Package "gbm" needed for this function to work. Please install it.',
call. = FALSE)
}
data('mtpl_be')
features <- setdiff(names(mtpl_be),c('id', 'nclaims', 'expo'))
set.seed(12345)
gbm_fit <- gbm::gbm(as.formula(paste('nclaims ~',
paste(features, sep = ' ', collapse = ' + '))),
distribution = 'poisson',
data = mtpl_be,
n.trees = 50,
interaction.depth = 3,
shrinkage = 0.1)
gbm_fun <- function(object, newdata) mean(predict(object, newdata, n.trees = object$n.trees, type = 'response'))
seg_dat <- gbm_fit %>% insights(vars = c('ageph', 'bm', 'coverage', 'fuel'),
data = mtpl_be,
interactions = 'auto',
hcut = 0.7,
pred_fun = gbm_fun) %>%
segmentation(data = mtpl_be,
lambda = 0.0001)
str(seg_dat)
sur_glm <- seg_dat %>% surrogate(par_list = alist(formula = nclaims ~ ageph_ + bm_ + fuel_ + ageph_bm_,
family =  poisson(link = 'log'),
offset = log(expo)))
test_that('output is of the correct format', {
sur_expl <- sur_glm %>% explain(instance = seg_dat[34, ], plt = FALSE)
expect_is(sur_expl, 'tbl_df')
expect_equal(ncol(sur_expl), 7)
expect_equal(nrow(sur_expl), length(attr(sur_glm$terms, 'term.labels')))
expect_true(all(sur_expl$term == gsub('_$', '', attr(sur_glm$terms, 'term.labels'))))
expect_equal(sum(is.na(sur_expl)), 0)
})
test_that('a ggplot is produced when asked for it', {
expect_is(sur_glm %>% explain(instance = seg_dat[34, ], plt = TRUE), 'ggplot')
})
test_that('an error is produced when multiple instances are provided as input', {
expect_error(sur_glm %>% explain(instance = seg_dat[1:3, ]),
'Can only explain one instance prediction at a time.')
})
library(maids)
# Use a gbm fit on the mtpl_be data to test the partial dependence function
if (!requireNamespace('gbm', quietly = TRUE)) {
stop('Package "gbm" needed for this function to work. Please install it.',
call. = FALSE)
}
data('mtpl_be')
features <- setdiff(names(mtpl_be),c('id', 'nclaims', 'expo'))
set.seed(12345)
gbm_fit <- gbm::gbm(as.formula(paste('nclaims ~',
paste(features, sep = ' ', collapse = ' + '))),
distribution = 'poisson',
data = mtpl_be,
n.trees = 50,
interaction.depth = 3,
shrinkage = 0.1)
gbm_fun <- function(object, newdata) mean(predict(object, newdata, n.trees = object$n.trees, type = 'response'))
fx_vars <- gbm_fit %>% insights(vars = c('ageph', 'bm', 'coverage', 'fuel', 'bm_fuel', 'ageph_coverage'),
data = mtpl_be,
interactions = 'user',
pred_fun = gbm_fun)
lmbd_tune <- fx_vars %>% autotune(data = mtpl_be,
target = 'nclaims',
lambdas = as.vector(outer(seq(1, 10, 1), 10^(-2:-1))),
nfolds = 5,
strat_vars = c('nclaims', 'expo'),
glm_par = alist(family = poisson(link = 'log'),
offset = log(expo)),
err_fun = poi_dev,
ncores = -1)
as.vector(outer(seq(1, 10, 1), 10^(-2:-1)))
lmbd_tune <- fx_vars %>% autotune(data = mtpl_be,
target = 'nclaims',
lambdas = as.vector(outer(seq(1, 10, 1), 10^(-4:-2))),
nfolds = 5,
strat_vars = c('nclaims', 'expo'),
glm_par = alist(family = poisson(link = 'log'),
offset = log(expo)),
err_fun = poi_dev,
ncores = -1)
lmbd_tune
expect_is(lmbd_tune, 'tbl_df')
expect_equal(nrow(lmbd_tune), 5)
expect_equal(ncol(lmbd_tune), 8 + length(names(fx_vars)))
expect_true(all(c('lambda_main', 'lambda_intr', 'cv_err', as.character(1:5), names(fx_vars)) %in% names(lmbd_tune)))
expect_equal(sum(is.na(lmbd_tune)), 0)
lmbd_tune
expect_is(lmbd_tune, 'tbl_df')
expect_equal(nrow(lmbd_tune), 7)
expect_equal(ncol(lmbd_tune), 8 + length(names(fx_vars)))
expect_true(all(c('lambda_main', 'lambda_intr', 'cv_err', as.character(1:5), names(fx_vars)) %in% names(lmbd_tune)))
expect_equal(sum(is.na(lmbd_tune)), 0)
expect_warning(fx_vars %>% autotune(data = mtpl_be,
target = 'nclaims',
lambdas = as.vector(outer(seq(1, 10, 1), 10^(-4:-2))),
nfolds = 2,
ncores = 10),
'The asked number of cores is larger than parallel::detectCores, so there might be trouble ahead.')
expect_warning(fx_vars %>% autotune(data = mtpl_be,
target = 'nclaims',
lambdas = as.vector(outer(seq(1, 10, 1), 10^(-4:-2))),
nfolds = 2,
glm_par = alist(formula = nclaims ~ 1)),
'The field "formula" is removed from glm_par as this is determined by the supplied target and automatic feature selection.')
# Create the hexSticker for maidrr
hexSticker::sticker('maidrr.png', package = 'maidrr',
s_x = 1, s_width = 1,
p_y = 1.55, p_color = '#2b60de',
h_size = 1, h_color = '#2b60de', h_fill = '#e6e6fa',
dpi = 720,
filename = 'inst/figures/maidrr_hex.png')
devtools::load_all(".")
library(maidrr)
?maidrr::autotune
library(maidrr)
file.exists("~/.ssh/id_rsa.pub")
